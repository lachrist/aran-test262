const {
  Worker, MessageChannel
} = require("worker_threads");

function ToBigInt64(value) {
  let n = BigInt(value);
  let int64bit = n % (2n ** 64n);
  if (int64bit > (2n ** 63n)) {
    return int64bit - (2n ** 64n);
  }
  return int64bit;
}

function ToInteger(value) {
  let number = Number(value);
  if (number !== number) {
    return 0;
  }
  if (number === 0 || !Number.isFinite(number)) {
    return number;
  }

  return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
}

function ToLength(value) {
  var len = ToInteger(value);
  if (len <= 0) {
    return 0;
  }
  if (len > Number.MAX_SAFE_INTEGER) {
    return Number.MAX_SAFE_INTEGER;
  }
  return len;
}

function ToIndex(value) {
  let index;
  if (value === undefined) {
    index = 0;
  } else {
    let integerIndex = ToInteger(value);
    if (integerIndex < 0) {
      throw new RangeError("Index out of range");
    }
    index = ToLength(integerIndex);
    if (integerIndex !== index) {
      throw new RangeError("Index out of range");
    }
  }
  return index;
}

function ValidateAtomicAccess(typedArray, requestIndex) {
  let accessIndex = ToIndex(requestIndex);
  let length = typedArray.length;

  if (accessIndex >= length) {
    throw new RangeError("Invalid atomic access index");
  }
  return accessIndex;
}

function waitAsync(ta, index_, value_, timeout_) {
  if (typeof ta != "object" ||
    (!(ta instanceof Int32Array) && !(ta instanceof BigInt64Array)) ||
    !(ta.buffer instanceof SharedArrayBuffer)) {
    throw new TypeError("Expected shared memory");
  }

  let index = ValidateAtomicAccess(ta, index_);
  let isBigInt = ta instanceof BigInt64Array;
  let constructor = isBigInt ? "BigInt64Array" : "Int32Array";
  let coersion = isBigInt ? (v => ToBigInt64(v)) : (v => v | 0);
  let value = coersion(value_);
  let timeout = timeout_ === undefined ? Infinity : +timeout_;
  let async = false;

  if (Atomics.load(ta, index) !== value) {
    return {
      async,
      value: "not-equal"
    };
  }

  if (timeout === 0) {
    return {
      async,
      value: "timed-out"
    };
  }

  async = true;

  return {
    async,
    value: new Promise((resolve, reject) => {
      const worker = new Worker(`
      require("/Users/rwaldron/clonez/eshost/runtimes/polyfills/node.js/atomics.waitasync.js");
      const { parentPort } = require("worker_threads");
      parentPort.once("message", ([constructor, buffer, index, value, timeout]) => {
        const ta = new global[constructor](buffer);
        parentPort.postMessage(Atomics.wait(ta, index, value, timeout));
        parentPort.close();
      });
      `, { eval: true });
      worker.once("message", (value) => {
        resolve(value);
        worker.terminate();
      });
      worker.postMessage([
        constructor,
        ta.buffer,
        index,
        value,
        timeout
      ]);
    })
  };
}

Object.defineProperty(Atomics, "waitAsync", {
  value: waitAsync,
  configurable: true,
  enumerable: false,
  writable: true,
});
